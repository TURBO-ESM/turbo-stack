#pragma once

#include <cstddef> // for std::size_t
#include <functional> // for std::function
#include <type_traits> // for std::is_invocable_r_v
#include <memory> // for std::shared_ptr
#include <vector>

#include <AMReX.H>
#include <AMReX_MultiFab.H>

class TripolarGrid {

public:
    using value_t = double;

    struct Point {
        value_t x, y, z;

        // Have the default comparison operator generated by the compiler... only works if all members are comparable and using c++20 or later.
        bool operator==(const Point&) const = default;

        // Component-wise addition
        Point operator+(const Point& other) const noexcept {
            return {x + other.x, y + other.y, z + other.z};
        }

    };

    TripolarGrid(std::size_t n_cell_x, std::size_t n_cell_y, std::size_t n_cell_z);

    std::size_t NCell() const noexcept  { return n_cell_x_ * n_cell_y_ * n_cell_z_; }
    std::size_t NCellX() const noexcept { return n_cell_x_; }
    std::size_t NCellY() const noexcept { return n_cell_y_; }
    std::size_t NCellZ() const noexcept { return n_cell_z_; }

    std::size_t NNode() const noexcept  { return NNodeX() * NNodeY() * NNodeZ(); }
    std::size_t NNodeX() const noexcept { return NCellX() + 1; }
    std::size_t NNodeY() const noexcept { return NCellY() + 1; }
    std::size_t NNodeZ() const noexcept { return NCellZ() + 1; }

    Point Node(amrex::IntVect node_index) const noexcept {
        return {x_min_ + node_index[0] * dx_,
                y_min_ + node_index[1] * dy_,
                z_min_ + node_index[2] * dz_};
    }

    Point CellCenter(amrex::IntVect cell_index) const noexcept {
        return Node(cell_index) + Point{dx_*0.5, dy_*0.5, dz_*0.5};
    }

    Point XFace(amrex::IntVect x_face_index) const noexcept {
        return Node(x_face_index) + Point{0.0, dy_*0.5, dz_*0.5};
    }

    Point YFace(amrex::IntVect y_face_index) const noexcept {
        return Node(y_face_index) + Point{dx_*0.5, 0.0, dz_*0.5};
    }

    Point ZFace(amrex::IntVect z_face_index) const noexcept {
        return Node(z_face_index) + Point{dx_*0.5, dy_*0.5, 0.0};
    }

    template <typename Func>
    void InitializeScalarMultifabs(Func value_func) noexcept {

        static_assert(
            std::is_invocable_r_v<double, Func, double, double, double>,
            "value_func must be callable as double(double, double, double)"
        );

        for (amrex::MFIter mfi(*cell_scalar); mfi.isValid(); ++mfi) {
            auto& arr = cell_scalar->array(mfi);
            const auto& box = mfi.validbox();
            amrex::ParallelFor(box, [=,this] AMREX_GPU_DEVICE(int i, int j, int k) {
                value_t x = x_min_ + i * dx_;
                value_t y = y_min_ + j * dy_;
                value_t z = z_min_ + k * dz_;
                arr(i, j, k) = value_func(x, y, z);
            });
        }
        // Repeat for x_face_scalar, y_face_scalar, z_face_scalar, node_scalar if needed
    }

    // A stand in for data saved at each location in the grid.
    std::shared_ptr<amrex::MultiFab> cell_scalar;
    std::shared_ptr<amrex::MultiFab> cell_vector;

    std::shared_ptr<amrex::MultiFab> x_face_scalar;
    std::shared_ptr<amrex::MultiFab> x_face_vector;

    std::shared_ptr<amrex::MultiFab> y_face_scalar;
    std::shared_ptr<amrex::MultiFab> y_face_vector;

    std::shared_ptr<amrex::MultiFab> z_face_scalar;
    std::shared_ptr<amrex::MultiFab> z_face_vector;

    std::shared_ptr<amrex::MultiFab> node_scalar;
    std::shared_ptr<amrex::MultiFab> node_vector;

    // Collections of MultiFabs for easier testing
    std::vector<std::shared_ptr<amrex::MultiFab>> all_multifabs;

    std::vector<std::shared_ptr<amrex::MultiFab>> scalar_multifabs;
    std::vector<std::shared_ptr<amrex::MultiFab>> vector_multifabs;

    std::vector<std::shared_ptr<amrex::MultiFab>> cell_multifabs;
    std::vector<std::shared_ptr<amrex::MultiFab>> x_face_multifabs;
    std::vector<std::shared_ptr<amrex::MultiFab>> y_face_multifabs;
    std::vector<std::shared_ptr<amrex::MultiFab>> z_face_multifabs;
    std::vector<std::shared_ptr<amrex::MultiFab>> node_multifabs;

private:

    // Number of cells in each direction
    const std::size_t n_cell_x_;
    const std::size_t n_cell_y_;
    const std::size_t n_cell_z_;
    
    // Domain dimensions... hardcoded for simplicity
    const double x_min_=0.0;
    const double y_min_=0.0;
    const double z_min_=0.0;

    const double x_max_=1.0;
    const double y_max_=1.0;
    const double z_max_=1.0;

    const double Lx_=x_max_-x_min_;
    const double Ly_=y_max_-y_min_;
    const double Lz_=z_max_-z_min_;

    // Grid spacing
    const double dx_=Lx_/n_cell_x_;
    const double dy_=Ly_/n_cell_y_;
    const double dz_=Lz_/n_cell_z_;


};
